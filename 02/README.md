# 02-redis

#### 过期时间设置及原理分析

##### 以秒为单位设置过期时间1

EXPIRE key seconds

##### 设置过期时间2

setex(String key,int seconds,String value)

##### 以毫秒为单位设置过期时间

PEXPIRE key seconds

##### 查看过期时间

ttl 

> 当键不存在时，TTL命令会返回-2
> 而对于没有给指定键设置过期时间的，通过TTL命令会返回-1



##### 清除过期时间

PERSIST key

> EXPIRE命令的seconds命令必须是整数，所以最小单位是1秒，如果向要更精确的控制键的过期时间可以使用PEXPIRE命令，当然实际过程中用秒的单位就够了。 PEXPIRE命令的单位是毫秒。即PEXPIRE key 1000与EXPIRE key 1相等；对应的PTTL以毫秒单位获取键的剩余有效时间



#### 过期删除的原理

Redis 中的主键失效是如何实现的，即失效的主键是如何删除的？实际上，Redis 删除失效主键的方法主要有两种：

##### 消极方法（passive way）

在主键被访问时如果发现它已经失效，那么就删除它

##### 积极方法（active way）

周期性地从设置了失效时间的主键中选择一部分失效的主键删除
对于那些从未被查询的key，即便它们已经过期，被动方式也无法清除。因此Redis会周期性地随机测试一些key

已过期的key将会被删掉。Redis每秒会进行10次操作，具体的流程：

1. 随机测试 20 个带有timeout信息的key；
2. 删除其中已经过期的key；
3. 如果超过25%的key被删除，则重复执行步骤1；这是一个简单的概率算法（trivial probabilistic algorithm），基于假设我们随机抽取的key代表了全部的key空间。



#### Redis持久化

> Redis支持两种方式的持久化，一种是RDB方式、另一种是AOF（append-only-file）方式。两种持久化方式可以单独使用其中一种，也可以将这两种方式结合使用

##### rdb

> 根据指定的规则“定时”将内存中的数据存储在硬盘上
>
> 当符合一定条件时，Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，等到持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
>
> 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。
>
> 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
>
> RDB的缺点是最后一次持久化后的数据可能丢失

##### rdd--fork线程的作用

> fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程

##### rdb数据快照方式

###### 根据配置规则进行自动快照

Redis允许用户自定义快照条件，当符合快照条件时，Redis会自动执行快照操作。快照的条件可以由用户在配置文件中配置。配置格式如下

save

> 第一个参数是时间窗口，第二个是键的个数
>
> 也就是说，在第一个时间参数配置范围内被更改的键的个数大于后面的changes时，即符合快照条件。redis默认配置了三个规则

save 900 1
save 300 10
save 60 10000
每条快照规则占一行，每条规则之间是“或”的关系。 在900秒（15分）内有一个以上的键被更改则进行快照。

###### 用户执行SAVE或者GBSAVE命令

除了让Redis自动进行快照以外，当我们对服务进行重启或者服务器迁移我们需要人工去干预备份。redis提供了两条命令来完成这个任务

save命令

> 当执行save命令时，Redis同步做快照操作，在快照执行过程中会阻塞所有来自客户端的请求。当redis内存中的数据较多时，通过该命令将导致Redis较长时间的不响应。所以不建议在生产环境上使用这个命令

bgsave命令

> bgsave命令可以在后台异步地进行快照操作，快照的同时服务器还可以继续响应来自客户端的请求。执行BGSAVE后，Redis会立即返回ok表示开始执行快照操作。
> 通过LASTSAVE命令可以获取最近一次成功执行快照的时间； （自动快照采用的是异步快照操作）



###### 执行FLUSHALL命令

> 该命令在前面讲过，会清除redis在内存中的所有数据。执行该命令后，只要redis中配置的快照规则不为空，也就是save 的规则存在。redis就会执行一次快照操作。不管规则是什么样的都会执行。如果没有定义快照规则，就不会执行快照操作

###### 执行复制(replication)时

> 该操作主要是在主从模式下，redis会在复制初始化时进行自动快照。及时没有定义自动快照规则，并且没有手动执行过快照操作，它仍然会生成RDB快照文件

##### aop

> 每次执行命令后将命令本身记录下来
>
> 当使用Redis存储非临时数据时，一般需要打开AOF持久化来降低进程终止导致的数据丢失。AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这一过程会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能
>
> 在启动时，Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相对于RDB会慢一些

##### 开启AOF

> 默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数启用，在redis.conf中找到 appendonly yes

> 开启AOF持久化后每执行一条会更改Redis中的数据的命令后，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是apendonly.aof. 可以在redis.conf中的属性 appendfilename appendonlyh.aof修改

##### 同步磁盘选项

appendsync 

> - always
> - everysec  每一秒钟
> - no

##### 设置aof文件名称

> appendfilename

##### AOF纯文本形式

AOF文件以纯文本的形式记录Redis执行的写命令例如开启AOF持久化的情况下执行如下4条命令

> set foo 1
> set foo 2
> set foo 3
> get

redis 会将前3条命令写入AOF文件中，通过vim的方式可以看到aof文件中的内容

> 我们会发现AOF文件的内容正是Redis发送的原始通信协议的内容，从内容中我们发现Redis只记录了3
> 条命令。然后这时有一个问题是前面2条命令其实是冗余的，因为这两条的执行结果都会被第三条命令覆盖。随着执行的命令越来越多，AOF文件的大小也会越来越大，其实内存中实际的数据可能没有多少，那这样就会**造成磁盘空间以及redis数据还原的过程比较长的问题**。因此我们希望Redis可以自动优化AOF文件，就上面这个例子来说，前面两条是可以被删除的。



##### 自动aof重写

###### 重写百分比

> auto-aof-rewrite-percentage 表示的是当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时AOF文件大小为依据

###### 重写的文件最小值

> auto-aof-rewrite-min-size 表示限制了允许重写的最小AOF文件大小，通常在AOF文件很小的情况下即使其中有很多冗余的命令我们也并不太关心。

##### 手动aof重写

> BGREWRITEAOF 命令手动执行AOF，执行完以后冗余的命令已经被删除了

##### AOF的重写原理

> aof重写文件 =  内存中数据 + aof_rewrite_buf的数据
>
> fork一个子线程，遍历内存中的所有数据，写入新的aof文件，当所有的数据全部追加到新的aof文件中后，把新的aof文件重命名为，此后所有的操作都会被写入新的aof文件。aof_rewrite_buf会记录aof期间写入的新数据，重写完以后再把缓存中的数据追加到新的aof文件。

> 如果在rewrite过程中出现故障，不会影响原来aof文件的正常工作，只有当rewrite完成后才会切换文件。因此这个rewrite过程是比较可靠的



#### Redis内存回收策略（maxmemory-policy）

Redis中提供了多种内存回收策略，当内存容量不足时，为了保证程序的运行，这时就不得不淘汰内存中的一些对象，释放这些对象占用的空间，那么选择淘汰哪些对象呢？



##### noeviction

默认的策略为noeviction策略，当内存使用达到阈值的时候，所有引起申请内存的命令会报错

##### allkeys-lru

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

###### 适合的场景

> 适合的场景： 如果我们的应用对缓存的访问都是相对热点数据，那么可以选择这个策略

##### allkeys-random

allkeys-random：随机移除某个key。

###### 适合的场景

> 适合的场景：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略

##### volatile-random

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。

##### volatile-lru

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。

##### volatile-ttl

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

###### 适合场景

> 适合场景：这种策略使得我们可以向Redis提示哪些key更适合被淘汰，我们可以自己控制





#### Redis是单进程单线程？性能为什么这么快

> 官方的解释是，CPU并不是Redis的瓶颈所在，Redis的瓶颈主要在机器的内存和网络的带宽。那么Redis能不能处理高并发请求呢？当然是可以的，至于怎么实现的，我们来具体了解一下。 【注意并发不等于并行，并发性I/O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。并行性，意味着服务器能够同时执行几个事情，具有多个计算单元】

##### 多路复用

> 